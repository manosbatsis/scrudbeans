// -------------------- DO NOT EDIT -------------------
//  This file is automatically generated by scrudbeans,
//  see https://manosbatsis.github.io/scrudbeans
//  To edit this file, copy it to the appropriate package 
//  in your src/main/kotlin folder and edit there. 
// ----------------------------------------------------
package mykotlinpackage.model

import com.fasterxml.jackson.`annotation`.JsonProperty
import com.github.manosbatsis.kotlin.utils.api.Dto
import com.github.manosbatsis.scrudbeans.api.domain.PersistenceHintsDto
import io.swagger.v3.oas.annotations.media.Schema
import java.math.BigDecimal
import java.util.UUID
import kotlin.Boolean
import kotlin.Int
import kotlin.Long

/**
 * A [OrderLine]-specific [Dto] implementation
 */
@Schema(
  name = "Order Line",
  description = "A model representing an order line",
)
public data class OrderLineDto(
  public var id: UUID? = null,
  public var version: Long? = null,
  @field:Schema(
    type = "int",
    description = "The desired quantity, default is 1",
    example = "2",
  )
  public var quantity: Int? = null,
  @field:Schema(
    type = "float",
    description = "The subtotal cost for this order line",
    readOnly = true,
    example = "3.05",
  )
  @field:JsonProperty(access = JsonProperty.Access.READ_ONLY)
  public var lineTotal: BigDecimal? = null,
  @field:Schema(
    title = "The product for this order line",
    required = true,
  )
  public var product: Product? = null,
  @field:Schema(
    title = "The parent order",
    required = true,
  )
  public var order: Order? = null,
) : Dto<OrderLine>, PersistenceHintsDto {
  /**
   * Alternative constructor, used to map 
   * from the given [OrderLine] instance.
   */
  public constructor(original: OrderLine) : this(
        id = original.id,
        version = original.version,
        quantity = original.quantity,
        lineTotal = original.lineTotal,
        product = original.product,
        order = original.order
  )

  public override fun isDetachedUpdate(): Boolean = false

  /**
   * Create a patched copy of the given [OrderLine] instance,
   * updated using this DTO's non-null properties.
   */
  public override fun toPatched(original: OrderLine): OrderLine {
    val patched = original
    errNonUpdatableOrOriginalValue("id", this.id, original.id)
    if(this.version != null) patched.version = this.version!!
    if(this.quantity != null) patched.quantity = this.quantity!!
    if(this.lineTotal != null) patched.lineTotal = this.lineTotal!!
    if(this.product != null) patched.product = this.product!!
    if(this.order != null) patched.order = this.order!!
    return patched
  }

  /**
   * Create an instance of [OrderLine], using this DTO's properties.
   * May throw a [DtoInsufficientStateMappingException] 
   * if there is mot enough information to do so.
   */
  public override fun toTargetType(): OrderLine {
    val instance = OrderLine(
      id = this.id ?: errNull("id"),
      quantity = this.quantity,
      lineTotal = this.lineTotal,
      product = this.product,
      order = this.order
    )
    version = this.version
    return instance
  }

  public companion object {
    /**
     * Create a new instance using the given [OrderLine] as source.
     */
    public fun from(original: OrderLine): OrderLineDto = OrderLineDto(
          id = original.id,
          version = original.version,
          quantity = original.quantity,
          lineTotal = original.lineTotal,
          product = original.product,
          order = original.order
    )

  }
}
